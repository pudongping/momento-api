// Code scaffolded by goctl. Safe to edit.
// goctl 1.9.2

package transaction

import (
	"context"

	"github.com/Masterminds/squirrel"
	"github.com/jinzhu/copier"
	"github.com/pkg/errors"
	"github.com/pudongping/momento-api/coreKit/ctxData"
	"github.com/pudongping/momento-api/coreKit/errcode"
	"github.com/pudongping/momento-api/internal/svc"
	"github.com/pudongping/momento-api/internal/types"
	"github.com/pudongping/momento-api/model"
	"github.com/spf13/cast"

	"github.com/zeromicro/go-zero/core/logx"
)

type TransactionListLogic struct {
	logx.Logger
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

// 获取交易流水列表
func NewTransactionListLogic(ctx context.Context, svcCtx *svc.ServiceContext) *TransactionListLogic {
	return &TransactionListLogic{
		Logger: logx.WithContext(ctx),
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *TransactionListLogic) TransactionList(req *types.TransactionListReq) (resp *types.TransactionListResp, err error) {
	userID := ctxData.GetUIDFromCtx(l.ctx)
	userIDUint := cast.ToUint64(userID)

	// 构建查询条件
	whereBuilder := squirrel.Eq{
		"user_id": userIDUint,
		"book_id": req.BookId,
	}
	
	builder := l.svcCtx.TransactionsModel.SelectBuilder().Where(whereBuilder)
	countBuilder := l.svcCtx.TransactionsModel.CountBuilder().Where(whereBuilder)

	if req.Type != "" {
		builder = builder.Where("type = ?", req.Type)
		countBuilder = countBuilder.Where("type = ?", req.Type)
	}
	if req.TagId > 0 {
		builder = builder.Where("tag_id = ?", req.TagId)
		countBuilder = countBuilder.Where("tag_id = ?", req.TagId)
	}
	if req.StartDate > 0 {
		builder = builder.Where("transaction_time >= ?", req.StartDate)
		countBuilder = countBuilder.Where("transaction_time >= ?", req.StartDate)
	}
	if req.EndDate > 0 {
		builder = builder.Where("transaction_time <= ?", req.EndDate)
		countBuilder = countBuilder.Where("transaction_time <= ?", req.EndDate)
	}

	// 计算总数
	total, err := l.svcCtx.TransactionsModel.FindCount(l.ctx, countBuilder)
	if err != nil {
		l.Logger.Errorf("TransactionList FindCount error: %v, userID: %d", err, userIDUint)
		return nil, errcode.DBError.WithError(err)
	}

	// 游标分页逻辑
	if req.LastTransactionId > 0 {
		lastTrans, err := l.svcCtx.TransactionsModel.FindOne(l.ctx, cast.ToUint64(req.LastTransactionId))
		if err != nil && !errors.Is(err, model.ErrNotFound) {
			l.Logger.Errorf("TransactionList FindOne lastTransactionId: %d error: %v", req.LastTransactionId, err)
			return nil, errcode.DBError.WithError(err)
		}
		
		if lastTrans != nil {
			// (transaction_time < last_time) OR (transaction_time = last_time AND transaction_id < last_id)
			// 假设按时间倒序，ID倒序
			builder = builder.Where(squirrel.Or{
				squirrel.Lt{"transaction_time": lastTrans.TransactionTime},
				squirrel.And{
					squirrel.Eq{"transaction_time": lastTrans.TransactionTime},
					squirrel.Lt{"transaction_id": lastTrans.TransactionId},
				},
			})
		}
	}

	// 排序和限制
	builder = builder.OrderBy("transaction_time DESC, transaction_id DESC")
	
	limit := req.PerPage
	if limit <= 0 {
		limit = 20
	}
	if limit > 100 {
		limit = 100
	}
	
	// 多查一条用于判断 has_more
	builder = builder.Limit(uint64(limit + 1))

	list, err := l.svcCtx.TransactionsModel.FindAll(l.ctx, builder)
	if err != nil {
		l.Logger.Errorf("TransactionList FindAll error: %v", err)
		return nil, errcode.DBError.WithError(err)
	}

	hasMore := false
	if len(list) > int(limit) {
		hasMore = true
		list = list[:limit]
	}

	// 收集 Tag IDs
	var tagIDs []uint64
	tagIDSet := make(map[uint64]struct{})
	for _, item := range list {
		if item.TagId > 0 {
			tagIDSet[item.TagId] = struct{}{}
		}
	}
	for id := range tagIDSet {
		tagIDs = append(tagIDs, id)
	}

	// 批量查询 Tags
	tagMap := make(map[uint64]*model.Tags)
	if len(tagIDs) > 0 {
		tagBuilder := l.svcCtx.TagsModel.SelectBuilder().Where(squirrel.Eq{"tag_id": tagIDs})
		tags, err := l.svcCtx.TagsModel.FindAll(l.ctx, tagBuilder)
		if err != nil {
			l.Logger.Errorf("TransactionList FindAll Tags error: %v", err)
			// 标签查询失败不影响主流程，只是没有标签信息
		} else {
			for _, t := range tags {
				tagMap[t.TagId] = t
			}
		}
	}

	// 组装响应
	var respList []types.TransactionItem
	for _, item := range list {
		tItem := types.TransactionItem{}
		// 基础字段拷贝
		_ = copier.Copy(&tItem, item)
		
		// 手动处理 ID 和 类型不匹配字段
		tItem.TransactionId = cast.ToString(item.TransactionId)
		tItem.UserId = cast.ToString(item.UserId)
		tItem.BookId = cast.ToInt64(item.BookId)
		tItem.TagId = cast.ToInt64(item.TagId)
		tItem.TransactionTime = cast.ToInt64(item.TransactionTime)
		tItem.CreatedAt = cast.ToInt64(item.CreatedAt)
		tItem.UpdatedAt = cast.ToInt64(item.UpdatedAt)
		tItem.IsAutoGenerated = cast.ToInt64(item.IsAutoGenerated)

		// 填充标签信息
		if tag, ok := tagMap[item.TagId]; ok {
			tItem.TagName = tag.Name
			tItem.TagColor = tag.Color
			tItem.TagIcon = tag.Icon
		}

		respList = append(respList, tItem)
	}

	return &types.TransactionListResp{
		List:    respList,
		HasMore: hasMore,
		Total:   total,
		Page:    req.Page,
		PerPage: limit,
	}, nil
}

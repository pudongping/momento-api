package transaction

import (
	"context"
	"strings"
	"time"

	"github.com/pudongping/momento-api/coreKit/ctxData"
	"github.com/pudongping/momento-api/coreKit/errcode"
	"github.com/pudongping/momento-api/internal/svc"
	"github.com/pudongping/momento-api/internal/types"
	"github.com/pudongping/momento-api/model"
	"github.com/spf13/cast"

	"github.com/zeromicro/go-zero/core/logx"
)

type TransactionAddLogic struct {
	logx.Logger
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

// 添加交易记录
func NewTransactionAddLogic(ctx context.Context, svcCtx *svc.ServiceContext) *TransactionAddLogic {
	return &TransactionAddLogic{
		Logger: logx.WithContext(ctx),
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *TransactionAddLogic) TransactionAdd(req *types.TransactionAddReq) (resp *types.TransactionAddResp, err error) {
	// 验证标签是否存在
	if err := l.checkTagExists(req.TagId); err != nil {
		return nil, err
	}

	// 获取当前登录用户 ID
	userID := cast.ToUint64(ctxData.GetUIDFromCtx(l.ctx))
	req.Remark = strings.TrimSpace(req.Remark)

	if req.IsRecurringEnabled {
		return l.addRecurringTransaction(userID, req)
	}

	return l.addNormalTransaction(userID, req)
}

// checkTagExists 验证标签是否存在
func (l *TransactionAddLogic) checkTagExists(tagId int64) error {
	_, err := l.svcCtx.TagsModel.FindOne(l.ctx, uint64(tagId))
	if err != nil {
		if err == model.ErrNotFound {
			return errcode.BadRequest.Msgr("标签不存在")
		}
		return errcode.DBError.Msgr("查询标签失败")
	}
	return nil
}

// addRecurringTransaction 添加周期性记账
func (l *TransactionAddLogic) addRecurringTransaction(userID uint64, req *types.TransactionAddReq) (*types.TransactionAddResp, error) {
	name := l.getRecurringName(req)
	now := uint64(time.Now().Unix())

	recurringData := &model.RecurringTransactions{
		BookId:             uint64(req.BookId),
		UserId:             userID,
		Name:               name,
		Type:               req.Type,
		Amount:             req.Amount,
		TagId:              uint64(req.TagId),
		Remark:             req.Remark,
		RecurringType:      req.RecurringType,
		RecurringHour:      uint64(req.RecurringHour),
		RecurringMinute:    uint64(req.RecurringMinute),
		RecurringWeekday:   uint64(req.RecurringWeekday),
		RecurringMonth:     uint64(req.RecurringMonth),
		RecurringDay:       uint64(req.RecurringDay),
		IsRecurringEnabled: model.RecurringTransactionIsEnabledYes, // 启用
		LastExecutedAt:     0,
		CreatedAt:          now,
		UpdatedAt:          now,
	}

	_, err := l.svcCtx.RecurringTransactionsModel.Insert(l.ctx, recurringData)
	if err != nil {
		l.Logger.Errorf("Insert recurring transaction failed: %v", err)
		return nil, errcode.DBError.Msgr("保存周期记账失败")
	}

	return &types.TransactionAddResp{}, nil
}

// addNormalTransaction 添加普通记账
func (l *TransactionAddLogic) addNormalTransaction(userID uint64, req *types.TransactionAddReq) (*types.TransactionAddResp, error) {
	now := uint64(time.Now().Unix())

	transactionData := &model.Transactions{
		BookId:          uint64(req.BookId),
		UserId:          userID,
		Type:            req.Type,
		Amount:          req.Amount,
		TagId:           uint64(req.TagId),
		Remark:          req.Remark,
		TransactionTime: uint64(req.CreatedAt), // 对应 DB transaction_time
		IsAutoGenerated: 2,                     // 手动添加
		CreatedAt:       now,
		UpdatedAt:       now,
	}

	_, err := l.svcCtx.TransactionsModel.Insert(l.ctx, transactionData)
	if err != nil {
		l.Logger.Errorf("Insert transaction failed: %v", err)
		return nil, errcode.DBError.Msgr("保存交易失败")
	}

	return &types.TransactionAddResp{}, nil
}

// getRecurringName 获取周期性记账名称
func (l *TransactionAddLogic) getRecurringName(req *types.TransactionAddReq) string {
	name := strings.TrimSpace(req.Name)
	if name != "" {
		return name
	}

	if req.Remark != "" {
		return req.Remark
	}

	typeName := "支出"
	if req.Type == "income" {
		typeName = "收入"
	}
	return "周期" + typeName
}

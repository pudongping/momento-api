package transaction

import (
	"context"
	"strings"
	"time"

	"github.com/pudongping/momento-api/coreKit/ctxData"
	"github.com/pudongping/momento-api/coreKit/errcode"
	"github.com/pudongping/momento-api/internal/svc"
	"github.com/pudongping/momento-api/internal/types"
	"github.com/pudongping/momento-api/model"

	"github.com/zeromicro/go-zero/core/logx"
)

type TransactionAddLogic struct {
	logx.Logger
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

// 添加交易记录
func NewTransactionAddLogic(ctx context.Context, svcCtx *svc.ServiceContext) *TransactionAddLogic {
	return &TransactionAddLogic{
		Logger: logx.WithContext(ctx),
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *TransactionAddLogic) TransactionAdd(req *types.TransactionAddReq) (resp *types.TransactionAddResp, err error) {
	// 获取当前登录用户 ID
	userID := ctxData.GetUIDFromCtx(l.ctx)

	// 查询标签信息
	_, err = l.svcCtx.TagsModel.FindOne(l.ctx, uint64(req.TagId))
	if err != nil {
		if err == model.ErrNotFound {
			return nil, errcode.BadRequest.Msgr("标签不存在")
		}
		return nil, errcode.DBError.Msgr("查询标签失败")
	}

	// 处理备注空格
	req.Remark = strings.TrimSpace(req.Remark)
	now := time.Now().Unix()

	if req.IsRecurringEnabled {
		// 处理周期性记账
		name := strings.TrimSpace(req.Name)
		if name == "" {
			if req.Remark != "" {
				name = req.Remark
			} else {
				typeName := "支出"
				if req.Type == "income" {
					typeName = "收入"
				}
				name = "周期" + typeName
			}
		}

		recurringData := &model.RecurringTransactions{
			BookId:             uint64(req.BookId),
			UserId:             uint64(userID),
			Name:               name,
			Type:               req.Type,
			Amount:             req.Amount,
			TagId:              uint64(req.TagId),
			Remark:             req.Remark,
			RecurringType:      req.RecurringType,
			RecurringHour:      uint64(req.RecurringHour),
			RecurringMinute:    uint64(req.RecurringMinute),
			RecurringWeekday:   uint64(req.RecurringWeekday),
			RecurringMonth:     uint64(req.RecurringMonth),
			RecurringDay:       uint64(req.RecurringDay),
			IsRecurringEnabled: 1, // 启用
			LastExecutedAt:     0,
			CreatedAt:          uint64(now),
			UpdatedAt:          uint64(now),
		}

		res, err := l.svcCtx.RecurringTransactionsModel.Insert(l.ctx, recurringData)
		if err != nil {
			l.Logger.Errorf("Insert recurring transaction failed: %v", err)
			return nil, errcode.DBError.Msgr("保存周期记账失败")
		}
		lastId, _ := res.LastInsertId()
		_ = lastId // 忽略 lastId 使用

		return &types.TransactionAddResp{}, nil

	} else {
		// 处理普通记账
		transactionData := &model.Transactions{
			BookId:          uint64(req.BookId),
			UserId:          uint64(userID),
			Type:            req.Type,
			Amount:          req.Amount,
			TagId:           uint64(req.TagId),
			Remark:          req.Remark,
			TransactionTime: uint64(req.CreatedAt), // 对应 DB transaction_time
			IsAutoGenerated: 2,                     // 手动添加
			CreatedAt:       uint64(now),
			UpdatedAt:       uint64(now),
		}

		res, err := l.svcCtx.TransactionsModel.Insert(l.ctx, transactionData)
		if err != nil {
			l.Logger.Errorf("Insert transaction failed: %v", err)
			return nil, errcode.DBError.Msgr("保存交易失败")
		}
		lastId, _ := res.LastInsertId()
		_ = lastId // 忽略 lastId 使用

		return &types.TransactionAddResp{}, nil
	}
}

package cron

import (
	"context"
	"fmt"
	"time"

	"github.com/Masterminds/squirrel"
	"github.com/pudongping/momento-api/internal/svc"
	"github.com/pudongping/momento-api/model"
	"github.com/zeromicro/go-zero/core/logx"
)

type RecurringJob struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

func NewRecurringJob(svcCtx *svc.ServiceContext) *RecurringJob {
	return &RecurringJob{
		ctx:    context.Background(),
		svcCtx: svcCtx,
	}
}

func (j *RecurringJob) Run() {
	logx.Info("Starting recurring transaction check...")

	// 为了防止单次执行时间过长，只处理截至到当前时间的任务
	now := time.Now()
	nowTimestamp := uint64(now.Unix())

	// 查询所有已启用且 next_execution_time <= now 的任务
	// 或者 next_execution_time = 0 (未初始化的任务)
	// 这里先查所有启用的，在内存中过滤，因为规则比较复杂，且数量一般不会太多
	// 如果数据量大，应该优化 SQL

	// 使用 squirrel 构建查询
	// SELECT * FROM recurring_transactions WHERE is_recurring_enabled = 1
	builder := j.svcCtx.RecurringTransactionsModel.SelectBuilder().
		Where(squirrel.Eq{"is_recurring_enabled": model.RecurringTransactionIsEnabledYes})

	recurringList, err := j.svcCtx.RecurringTransactionsModel.FindAll(j.ctx, builder)
	if err != nil {
		logx.Errorf("Failed to fetch recurring transactions: %v", err)
		return
	}

	for _, recurring := range recurringList {
		j.processRecurring(recurring, nowTimestamp)
	}

	logx.Info("Finished recurring transaction check.")
}

func (j *RecurringJob) processRecurring(recurring *model.RecurringTransactions, nowTimestamp uint64) {
	// 1. 初始化检查
	if recurring.NextExecutionTime == 0 {
		nextTime := j.calculateFirstExecutionTime(recurring)
		recurring.NextExecutionTime = uint64(nextTime)
		if err := j.svcCtx.RecurringTransactionsModel.Update(j.ctx, recurring); err != nil {
			logx.Errorf("Failed to update recurring transaction %d init time: %v", recurring.RecurringId, err)
		}
		return
	}

	// 2. 检查是否到期
	if recurring.NextExecutionTime > nowTimestamp {
		return
	}

	// 3. 循环处理直到追上当前时间（或达到最大追赶次数）
	// 限制最大追赶次数，防止死循环或一次性生成过多数据
	maxCatchUp := 12
	catchUpCount := 0

	// 这里的逻辑是：如果错过了多次，会补齐
	currentExecutionTime := recurring.NextExecutionTime

	for currentExecutionTime <= nowTimestamp && catchUpCount < maxCatchUp {
		// 执行记账
		if err := j.executeTransaction(recurring, currentExecutionTime); err != nil {
			logx.Errorf("Failed to execute transaction for recurring %d at %d: %v", recurring.RecurringId, currentExecutionTime, err)
			break // 如果出错，停止当前任务的处理，避免重复错误
		}

		// 计算下一次执行时间
		nextTime := j.calculateNextExecutionTime(recurring, int64(currentExecutionTime))
		currentExecutionTime = uint64(nextTime)
		catchUpCount++
	}

	// 4. 更新下一次执行时间
	recurring.NextExecutionTime = currentExecutionTime
	recurring.LastExecutedAt = uint64(time.Now().Unix()) // 记录最后一次处理的时间
	recurring.UpdatedAt = uint64(time.Now().Unix())

	if err := j.svcCtx.RecurringTransactionsModel.Update(j.ctx, recurring); err != nil {
		logx.Errorf("Failed to update recurring transaction %d next time: %v", recurring.RecurringId, err)
	}
}

func (j *RecurringJob) executeTransaction(recurring *model.RecurringTransactions, executionTime uint64) error {
	newTransaction := &model.Transactions{
		BookId:          recurring.BookId,
		UserId:          recurring.UserId,
		Type:            recurring.Type,
		Amount:          recurring.Amount,
		TagId:           recurring.TagId,
		Remark:          fmt.Sprintf("%s (自动生成)", recurring.Name),
		TransactionTime: executionTime,
		IsAutoGenerated: 1, // 是自动生成
		CreatedAt:       uint64(time.Now().Unix()),
		UpdatedAt:       uint64(time.Now().Unix()),
	}

	// 如果原备注有内容，拼接到备注中
	if recurring.Remark != "" {
		newTransaction.Remark = fmt.Sprintf("%s - %s", recurring.Name, recurring.Remark)
	}

	_, err := j.svcCtx.TransactionsModel.Insert(j.ctx, newTransaction)
	return err
}

func (j *RecurringJob) calculateFirstExecutionTime(recurring *model.RecurringTransactions) int64 {
	// 基于当前时间计算下一次
	now := time.Now()

	// 如果今天的时间已经过了，从明天开始算？或者按照周期算？
	// 这里简单处理：如果设置的时间在当前时间之前，就认为是“过去”，需要计算下一个周期
	// 如果设置的时间在当前时间之后，就是这一次

	// 但还要考虑 weekday, day of month 等
	// 这其实和 calculateNextExecutionTime 逻辑类似，只是基准点是 "now"

	// 简单策略：先假设是 Start，如果 Start < Now，则计算 Next(Start) 直到 > Now
	// 或者更简单的：认为基准是 Start，然后调用一次 calculateNext 逻辑（需要稍微调整逻辑以支持“找到未来第一个匹配点”）

	// 为了复用逻辑，我们先定一个基准时间。
	// 如果是 Daily，基准就是 Start。
	// 如果是 Weekly，需要找到最近的 Weekday。

	// 这里简化：直接返回 calculateNextExecutionTime 的结果，基准设为 now - 1秒?
	// 不行，calculateNext 是基于“上一次执行时间”加一个周期。

	// 让我们实现一个 helper：findNextSchedule(afterTime, recurring)
	return j.findNextSchedule(now, recurring)
}

func (j *RecurringJob) calculateNextExecutionTime(recurring *model.RecurringTransactions, lastExecutionTimestamp int64) int64 {
	lastTime := time.Unix(lastExecutionTimestamp, 0)

	switch recurring.RecurringType {
	case "daily":
		return lastTime.AddDate(0, 0, 1).Unix()
	case "weekly":
		return lastTime.AddDate(0, 0, 7).Unix()
	case "monthly":
		// 保持日期的月份增加
		// 注意：AddDate(0, 1, 0) 会自动处理溢出，比如 1.31 + 1月 -> 3.03 (平年)
		// 我们通常希望是 2.28
		return addMonths(lastTime, 1).Unix()
	case "quarterly":
		return addMonths(lastTime, 3).Unix()
	case "yearly":
		return addMonths(lastTime, 12).Unix()
	default:
		return lastTime.AddDate(0, 0, 1).Unix() // 默认按天
	}
}

// addMonths 增加月份，但尽量保持“日”不变，如果目标月没有该日，则取目标月最后一天
func addMonths(t time.Time, months int) time.Time {
	// 获取原日期的年月日
	year, month, day := t.Date()

	// 计算目标年月
	targetMonthVal := int(month) + months
	targetYear := year + (targetMonthVal-1)/12
	targetMonth := time.Month((targetMonthVal-1)%12 + 1)

	// 获取目标月的最大天数
	// 方法：下个月的第0天
	nextMonth := time.Date(targetYear, targetMonth+1, 0, 0, 0, 0, 0, t.Location())
	maxDay := nextMonth.Day()

	targetDay := day
	if targetDay > maxDay {
		targetDay = maxDay
	}

	return time.Date(targetYear, targetMonth, targetDay, t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), t.Location())
}

func (j *RecurringJob) findNextSchedule(afterTime time.Time, recurring *model.RecurringTransactions) int64 {
	// 构造当天的目标时间
	target := time.Date(afterTime.Year(), afterTime.Month(), afterTime.Day(), int(recurring.RecurringHour), int(recurring.RecurringMinute), 0, 0, afterTime.Location())

	// 如果 target 在 afterTime 之前，说明今天已经过了，至少要从明天（或下一个周期）开始
	if target.Before(afterTime) {
		target = target.AddDate(0, 0, 1)
	}

	switch recurring.RecurringType {
	case "daily":
		// 就是 target (或者 target 已经是明天)
		return target.Unix()
	case "weekly":
		// 找到下一个 Weekday
		// recurring.RecurringWeekday: 0-6 (周日-周六)
		// time.Weekday(): Sunday=0
		targetWeekday := time.Weekday(recurring.RecurringWeekday)
		currentWeekday := target.Weekday()

		daysToAdd := (int(targetWeekday) - int(currentWeekday) + 7) % 7
		if daysToAdd == 0 && target.Before(afterTime) {
			daysToAdd = 7
		}
		return target.AddDate(0, 0, daysToAdd).Unix()
	case "monthly":
		// 找到下一个 Month 的 RecurringDay
		// recurring.RecurringDay
		// 注意：如果当前月份的 recurringDay 已经过了，或者当前月份没有 recurringDay，则找下个月

		// 重新以此刻的年月构建，但用 recurringDay
		y, m, _ := target.Date()
		// 尝试构建本月的执行时间
		thisMonthTarget := j.getValidDate(y, m, int(recurring.RecurringDay), int(recurring.RecurringHour), int(recurring.RecurringMinute), target.Location())

		if thisMonthTarget.After(afterTime) {
			return thisMonthTarget.Unix()
		}

		// 否则是下个月
		nextMonthTarget := addMonths(thisMonthTarget, 1)
		return nextMonthTarget.Unix()

	case "quarterly":
		// 类似 monthly，但是间隔3个月。
		// 这里简化：找到下一个符合 recurringDay 的月份。
		// 但 quarterly 通常意味着从“开始时间”起每3个月。
		// 由于我们是首次初始化，我们假设从“当前月份”开始找。
		y, m, _ := target.Date()
		thisMonthTarget := j.getValidDate(y, m, int(recurring.RecurringDay), int(recurring.RecurringHour), int(recurring.RecurringMinute), target.Location())

		if thisMonthTarget.After(afterTime) {
			return thisMonthTarget.Unix()
		}
		return addMonths(thisMonthTarget, 3).Unix()

	case "yearly":
		// 每年 recurringMonth, recurringDay
		y, _, _ := target.Date()
		thisYearTarget := j.getValidDate(y, time.Month(recurring.RecurringMonth), int(recurring.RecurringDay), int(recurring.RecurringHour), int(recurring.RecurringMinute), target.Location())

		if thisYearTarget.After(afterTime) {
			return thisYearTarget.Unix()
		}
		return thisYearTarget.AddDate(1, 0, 0).Unix()
	}

	return target.Unix()
}

func (j *RecurringJob) getValidDate(year int, month time.Month, day, hour, min int, loc *time.Location) time.Time {
	// 获取该月最大天数
	nextMonth := time.Date(year, month+1, 0, 0, 0, 0, 0, loc)
	maxDay := nextMonth.Day()
	if day > maxDay {
		day = maxDay
	}
	return time.Date(year, month, day, hour, min, 0, 0, loc)
}

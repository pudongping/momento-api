// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.9.2

package model

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"

	"github.com/Masterminds/squirrel"
	"github.com/pudongping/momento-api/coreKit/paginator"
)

var (
	recurringTransactionsFieldNames          = builder.RawFieldNames(&RecurringTransactions{})
	recurringTransactionsRows                = strings.Join(recurringTransactionsFieldNames, ",")
	recurringTransactionsRowsExpectAutoSet   = strings.Join(stringx.Remove(recurringTransactionsFieldNames, "`recurring_id`"), ",")
	recurringTransactionsRowsWithPlaceHolder = strings.Join(stringx.Remove(recurringTransactionsFieldNames, "`recurring_id`"), "=?,") + "=?"
)

type (
	recurringTransactionsModel interface {
		Insert(ctx context.Context, data *RecurringTransactions) (sql.Result, error)

		// 自定义模版中扩展的方法 start ----->
		GetTableName() string
		Transaction(ctx context.Context, fn func(ctx context.Context, session sqlx.Session) error) error
		ExecContext(ctx context.Context, session sqlx.Session, query string, args ...interface{}) (sql.Result, error)
		InsertWithSession(ctx context.Context, session sqlx.Session, insertData map[string]interface{}) (sql.Result, error)
		DeleteFilter(ctx context.Context, session sqlx.Session, where squirrel.Sqlizer) (sql.Result, error)
		UpdateFilter(ctx context.Context, session sqlx.Session, updateData map[string]interface{}, where squirrel.Sqlizer) (sql.Result, error)
		SelectBuilder(fields ...string) squirrel.SelectBuilder
		CountBuilder(field ...string) squirrel.SelectBuilder
		SumBuilder(field string) squirrel.SelectBuilder
		FindCount(ctx context.Context, countBuilder squirrel.SelectBuilder) (int64, error)
		FindSum(ctx context.Context, sumBuilder squirrel.SelectBuilder) (float64, error)
		FindAny(ctx context.Context, rowBuilder squirrel.SelectBuilder, bindings interface{}) error
		FindOneByQuery(ctx context.Context, rowBuilder squirrel.SelectBuilder) (*RecurringTransactions, error)
		FindAll(ctx context.Context, rowBuilder squirrel.SelectBuilder) ([]*RecurringTransactions, error)
		FindListByPage(ctx context.Context, rowBuilder squirrel.SelectBuilder, page, perPage int64, orderBy string) ([]*RecurringTransactions, *paginator.Pagination, error)
		// 自定义模版中扩展的方法 end ---->
		FindOne(ctx context.Context, recurringId uint64) (*RecurringTransactions, error)
		Update(ctx context.Context, data *RecurringTransactions) error
		Delete(ctx context.Context, recurringId uint64) error
	}

	defaultRecurringTransactionsModel struct {
		conn  sqlx.SqlConn
		table string
	}

	RecurringTransactions struct {
		RecurringId        uint64  `db:"recurring_id"`         // 周期性记账ID
		BookId             uint64  `db:"book_id"`              // 账本ID
		UserId             uint64  `db:"user_id"`              // 用户ID
		Name               string  `db:"name"`                 // 记账名称
		Type               string  `db:"type"`                 // 交易类型
		Amount             float64 `db:"amount"`               // 金额
		TagId              uint64  `db:"tag_id"`               // 标签ID
		Remark             string  `db:"remark"`               // 备注
		RecurringType      string  `db:"recurring_type"`       // 周期类型
		RecurringHour      uint64  `db:"recurring_hour"`       // 执行小时（0-23）
		RecurringMinute    uint64  `db:"recurring_minute"`     // 执行分钟（0-59）
		RecurringWeekday   uint64  `db:"recurring_weekday"`    // 星期几（0-6，0为周日）
		RecurringMonth     uint64  `db:"recurring_month"`      // 月份（1-12）
		RecurringDay       uint64  `db:"recurring_day"`        // 日期（1-31）
		IsRecurringEnabled int64   `db:"is_recurring_enabled"` // 是否启用 1-是 2-否
		LastExecutedAt     uint64  `db:"last_executed_at"`     // 最后执行时间（秒级时间戳）
		NextExecutionTime  uint64  `db:"next_execution_time"`  // 下一次执行时间（秒级时间戳）
		CreatedAt          uint64  `db:"created_at"`           // 创建时间（秒级时间戳）
		UpdatedAt          uint64  `db:"updated_at"`           // 更新时间（秒级时间戳）
	}
)

func newRecurringTransactionsModel(conn sqlx.SqlConn) *defaultRecurringTransactionsModel {
	return &defaultRecurringTransactionsModel{
		conn:  conn,
		table: "`recurring_transactions`",
	}
}

func (m *defaultRecurringTransactionsModel) Delete(ctx context.Context, recurringId uint64) error {
	query := fmt.Sprintf("delete from %s where `recurring_id` = ?", m.table)
	_, err := m.conn.ExecCtx(ctx, query, recurringId)
	return err
}

func (m *defaultRecurringTransactionsModel) FindOne(ctx context.Context, recurringId uint64) (*RecurringTransactions, error) {
	query := fmt.Sprintf("select %s from %s where `recurring_id` = ? limit 1", recurringTransactionsRows, m.table)
	var resp RecurringTransactions
	err := m.conn.QueryRowCtx(ctx, &resp, query, recurringId)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultRecurringTransactionsModel) Insert(ctx context.Context, data *RecurringTransactions) (sql.Result, error) {
	query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, recurringTransactionsRowsExpectAutoSet)
	ret, err := m.conn.ExecCtx(ctx, query, data.BookId, data.UserId, data.Name, data.Type, data.Amount, data.TagId, data.Remark, data.RecurringType, data.RecurringHour, data.RecurringMinute, data.RecurringWeekday, data.RecurringMonth, data.RecurringDay, data.IsRecurringEnabled, data.LastExecutedAt, data.NextExecutionTime, data.CreatedAt, data.UpdatedAt)
	return ret, err
}

// 自定义模版中扩展的方法 start ----->

func (m *defaultRecurringTransactionsModel) GetTableName() string {
	return m.tableName()
}

func (m *defaultRecurringTransactionsModel) Transaction(ctx context.Context, fn func(ctx context.Context, session sqlx.Session) error) error {

	return m.conn.TransactCtx(ctx, func(ctx context.Context, session sqlx.Session) error {
		return fn(ctx, session)
	})

}

func (m *defaultRecurringTransactionsModel) ExecContext(ctx context.Context, session sqlx.Session, query string, args ...interface{}) (sql.Result, error) {
	if session != nil {
		return session.ExecCtx(ctx, query, args...)
	}
	return m.conn.ExecCtx(ctx, query, args...)
}

func (m *defaultRecurringTransactionsModel) InsertWithSession(ctx context.Context, session sqlx.Session, insertData map[string]interface{}) (sql.Result, error) {
	insertBuilder := squirrel.Insert(m.table).SetMap(insertData)
	query, values, err := insertBuilder.ToSql()
	if err != nil {
		return nil, err
	}

	return m.ExecContext(ctx, session, query, values...)
}

func (m *defaultRecurringTransactionsModel) DeleteFilter(ctx context.Context, session sqlx.Session, where squirrel.Sqlizer) (sql.Result, error) {
	deleteBuilder := squirrel.Delete(m.table).Where(where)
	query, values, err := deleteBuilder.ToSql()
	if err != nil {
		return nil, err
	}

	return m.ExecContext(ctx, session, query, values...)
}

func (m *defaultRecurringTransactionsModel) UpdateFilter(ctx context.Context, session sqlx.Session, updateData map[string]interface{}, where squirrel.Sqlizer) (sql.Result, error) {
	updateBuilder := squirrel.Update(m.table).SetMap(updateData).Where(where)
	query, values, err := updateBuilder.ToSql()
	if err != nil {
		return nil, err
	}

	return m.ExecContext(ctx, session, query, values...)
}

func (m *defaultRecurringTransactionsModel) SelectBuilder(fields ...string) squirrel.SelectBuilder {
	f := recurringTransactionsRows
	if len(fields) > 0 {
		f = strings.Join(fields, ",")
	}
	return squirrel.Select(f).From(m.table)
}

func (m *defaultRecurringTransactionsModel) CountBuilder(field ...string) squirrel.SelectBuilder {
	f := "*"
	if len(field) > 0 && field[0] != "" {
		f = field[0]
	}
	return squirrel.Select("COUNT(" + f + ")").From(m.table)
}

func (m *defaultRecurringTransactionsModel) SumBuilder(field string) squirrel.SelectBuilder {
	return squirrel.Select("IFNULL(SUM(" + field + "),0)").From(m.table)
}

func (m *defaultRecurringTransactionsModel) FindCount(ctx context.Context, countBuilder squirrel.SelectBuilder) (int64, error) {
	query, values, err := countBuilder.ToSql()
	if err != nil {
		return 0, err
	}

	var resp int64

	err = m.conn.QueryRowCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return resp, nil
	default:
		return 0, err
	}
}

func (m *defaultRecurringTransactionsModel) FindSum(ctx context.Context, sumBuilder squirrel.SelectBuilder) (float64, error) {
	query, values, err := sumBuilder.ToSql()
	if err != nil {
		return 0, err
	}

	var resp float64

	err = m.conn.QueryRowCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return resp, nil
	default:
		return 0, err
	}
}

func (m *defaultRecurringTransactionsModel) FindAny(ctx context.Context, rowBuilder squirrel.SelectBuilder, bindings interface{}) error {
	query, values, err := rowBuilder.ToSql()
	if err != nil {
		return err
	}

	return m.conn.QueryRowsCtx(ctx, bindings, query, values...)

}

func (m *defaultRecurringTransactionsModel) FindOneByQuery(ctx context.Context, rowBuilder squirrel.SelectBuilder) (*RecurringTransactions, error) {
	query, values, err := rowBuilder.ToSql()
	if err != nil {
		return nil, err
	}

	var resp RecurringTransactions

	err = m.conn.QueryRowCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return &resp, nil
	default:
		return nil, err
	}

}

func (m *defaultRecurringTransactionsModel) FindAll(ctx context.Context, rowBuilder squirrel.SelectBuilder) ([]*RecurringTransactions, error) {
	query, values, err := rowBuilder.ToSql()
	if err != nil {
		return nil, err
	}

	var resp []*RecurringTransactions

	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}

func (m *defaultRecurringTransactionsModel) FindListByPage(ctx context.Context, rowBuilder squirrel.SelectBuilder, page, perPage int64, orderBy string) ([]*RecurringTransactions, *paginator.Pagination, error) {
	// 构建查询数据总条数的 sql 语句
	countQuery, countValues, err := paginator.CountDataSqlBuilder(rowBuilder).ToSql()
	if err != nil {
		return nil, nil, err
	}

	var total int64

	err = m.conn.QueryRowCtx(ctx, &total, countQuery, countValues...)

	if err != nil {
		return nil, nil, err
	}

	currentPage, limit, offset := paginator.PrepareOffsetLimit(page, perPage)
	pagination := paginator.NewPagination(total, currentPage, limit)

	builder := rowBuilder.Offset(uint64(offset)).Limit(uint64(limit))
	builder = paginator.WithOrderBy(orderBy, builder)

	query, values, err := builder.ToSql()
	if err != nil {
		return nil, nil, err
	}

	var resp []*RecurringTransactions

	err = m.conn.QueryRowsCtx(ctx, &resp, query, values...)

	switch err {
	case nil:
		return resp, pagination, nil
	default:
		return nil, nil, err
	}
}

// 自定义模版中扩展的方法 end ---->

func (m *defaultRecurringTransactionsModel) Update(ctx context.Context, data *RecurringTransactions) error {
	query := fmt.Sprintf("update %s set %s where `recurring_id` = ?", m.table, recurringTransactionsRowsWithPlaceHolder)
	_, err := m.conn.ExecCtx(ctx, query, data.BookId, data.UserId, data.Name, data.Type, data.Amount, data.TagId, data.Remark, data.RecurringType, data.RecurringHour, data.RecurringMinute, data.RecurringWeekday, data.RecurringMonth, data.RecurringDay, data.IsRecurringEnabled, data.LastExecutedAt, data.NextExecutionTime, data.CreatedAt, data.UpdatedAt, data.RecurringId)
	return err
}

func (m *defaultRecurringTransactionsModel) tableName() string {
	return m.table
}
